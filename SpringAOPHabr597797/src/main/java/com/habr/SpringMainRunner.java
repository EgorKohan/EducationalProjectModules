package com.habr;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Четкое разделение бизнес логики с другими сквозными задачами является обязательным условием для создания чистого и читабельного кода. И говоря о сквозных задачах я имею ввиду управление транзакциями, безопасность и прочие важные задачи, которые хоть и не относятся к бизнес логике напрямую - но оказывают существенное влияние на работу приложения в целом. В случае "жесткого связывания" основной логики и подобных задач - мы можем получить кучу проблем в случае ошибки последних. АОП, собственно, и нацелено на решение подобных задач.
 * <p>
 * Аспектно-ориентированное программирование - это отличный инструмент для решения проблем, которые не относятся к бизнес логике напрямую. Оно позволяет добавить поведение в существующий код, не меняя его функционал. АОП дополняет ООП, предоставляя еще один способ достижения модульности и большей чистоты кода.
 * <p>
 * Spring имеет свою собственную структуру АОП, которая концептуально проста для понимания и является отличным решением большинства проблем в корпоративных Java-приложениях. В этой статье мы собираемся рассмотреть магию Spring АОП - со всеми его достоинствами и недостатками. Если у вас вообще нет никакого понимания за данную тему - рекомендую почитать данный материал.
 * <p>
 * Прокси в нашем случае - это объект, созданный при помощи АОП для реализации так называемых аспектных контрактов. Проще говоря, это обертка вокруг экземпляра bean, которая может использовать функционал оригинального бина но со своими доработками. Spring использует прокси под капотом для автоматического добавления дополнительного поведения без изменения существующего кода. Это достигается одним из двух способов:
 * <p>
 * JDK dynamic proxy - Spring AOP по умолчанию использует JDK dynamic proxy, которые позволяют проксировать любой интерфейс (или набор интерфейсов). Если целевой объект реализует хотя бы один интерфейс, то будет использоваться динамический прокси JDK.
 * <p>
 * CGLIB-прокси - используется по умолчанию, если бизнес-объект не реализует ни одного интерфейса.
 * <p>
 * Так как прокси по сути просто оборачивает bean - он может добавить логику до и после выполнения методов. Что он, по сути, и делает.
 *
 * <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/a50/338/cb3/a50338cb34eb7cee2928f5cc54e0063d.png"/>
 * <p>
 * Spring при помощи определенных аннотаций понимает, какой класс нужно обернуть в прокси. На этапе вызова метода у нужного бина спринг возвращает уже не оригинал бина - а его прокси-обертку. Вызванный метод попадает в этот самый прокси объект в котором сначала выполняется логика до - далее вызываем реальный метод - и в конце делаем логику после. Таким образом можно реализовать любую дополнительную логику по типу логирования, транзакционности, метрики и т.д. для дальнейшего понимания процесса нам необходимо разобраться с основной терминологией АОП.
 * <p>
 * <ul>
 * <li>
 * Aspect: некий код, который актуален для несколько классов. Управление транзакциями является хорошим примером сквозного аспекта в корпоративных Java-приложениях. В Spring AOP аспекты реализуются с помощью аннотации @Aspect (стиль@AspectJJ) или XML-конфигурации для класса.
 * </li>
 * <li>
 * Join point: точка во время выполнения программы, такая как выполнение метода или обработка исключения. В Spring AOP точка соединения всегда представляет собой выполнение метода.
 * </li>
 * <li>
 * Advice: действие, предпринимаемое аспектом в определенной точке соединения. Advice можно разделить на те, которые выполняются только "до" основной логики метода либо "после" либо "вокруг" (и до и после). Многие AOP-фреймворки, включая Spring, моделируют advice как перехватчик который поддерживает цепочку других перехватчиков вокруг точки соединения.
 * </li>
 * <li>
 * Pointcut: предикат, который соответствует join point. Advice ассоциируется с выражением pointcut и запускается в любой точке соединения, совпадающей с указателем (например, выполнение метода с определенным именем). Концепция точек соединения (join point), сопоставляемых выражениями pointcut, является центральной в AOP, и Spring по умолчанию использует язык выражений AspectJ pointcut.
 * </li>
 * <li>
 * Introduction: объявление дополнительных методов или полей от имени типа. Spring AOP позволяет вам вводить новые интерфейсы (и соответствующую реализацию) в любой рекомендуемый объект. Например, вы можете использовать introduction, чтобы заставить bean реализовать интерфейс IsModified, чтобы упростить кэширование.
 * </li>
 * <li>
 * Target object: объект, который советуется одним или несколькими аспектами. Также известен как "advised object". Поскольку Spring AOP реализуется с помощью прокси во время выполнения, этот объект всегда является проксированным объектом.
 * </li>
 * <li>
 * AOP proxy: объект, созданный AOP-фреймворком для реализации аспектов. В Spring Framework прокси AOP - это динамический прокси JDK или прокси CGLIB.
 * </li>
 * <li>
 * Weaving: связывание аспектов с другими типами приложений или объектами для создания нужной логики. Это может быть сделано во время компиляции (например, с помощью компилятора AspectJ), во время загрузки или во время выполнения. Spring AOP, как и другие чисто Java AOP-фреймворки, выполняет weaving во время выполнения.
 * </li>
 * </ul>
 * <p>
 * Когда spring определяет, что bean Test советует одним или несколькими аспектами, он автоматически генерирует для него прокси,
 * чтобы перехватывать все вызовы методов и выполнять дополнительную логику, когда это необходимо. Однако из вывода видно,
 * что дополнительная логика работает для pojo.testUtil(), но не для this.testUtil(). Почему так?
 * Потому что последний перехватывается не прокси, а реальным целевым классом. В результате прокси никогда не срабатывает. Давайте посмотрим детальнее:
 *
 * <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/87d/210/194/87d210194a5df3daa2c12c684e47d736.png"/>
 * <p>
 * Вызов pojo.test()происходит на объекте класса Pojo. Спринг перехватывает данный вызов и создает прокси, который, в свою очередь, вызывает advice.
 * Advice непосредственно вызывает целевой метод.
 * И проблема заключается в том, что целевой метод сам у себя вызывает еще один метод, о котором спринг ничего не знает. Для понимания кратко еще раз:
 * <ol>
 * <li>
 * Прокси создан
 * </li>
 * <li>
 * Вызвана какая-то логика до основного метода
 * </li>
 * <li>
 * Происходит вызов основного метода
 * </li>
 * <li>
 * Данный метод внутри себя "что-то делает" и что именно - прокси не имеет понятия.
 * </li>
 * <li>
 * В числе этих самых "что-то" метод вызывает другой метод не через бин - а у себя напрямую. Таким образом, вызов самого себя не приводит к выполнению условий создания прокси.
 * </li>
 * </ol>
 *
 * Примечание: Аннотация @Aspect на классе помечает его кандидатом в прокси и, следовательно, исключает его из автопроксирования.
 * Следовательно, в Spring AOP невозможно, чтобы сами аспекты были целью рекомендаций от других аспектов.
 *
 * Поскольку прокси является дополнительным промежуточным звеном между вызывающим кодом и целевым объектом, неудивительно, что возникают некоторые накладные расходы. Примечательно, что эти накладные расходы фиксированы. Прокси-вызов добавляет фиксированную задержку независимо от времени выполнения обычного метода. Вопрос в том, должна ли нас волновать эта задержка? И да, и нет!
 *
 * Если дополнительное поведение само по себе имеет гораздо большее влияние на производительность (например, кэширование или управление транзакциями), чем сам механизм проксирования, то накладные расходы кажутся незначительными. Однако, если поведение должно применяться к большому количеству объектов (например, протоколирование каждого метода), то накладные расходы уже не являются незначительными.
 *
 * Еще один момент, вызывающий беспокойство, - это количество проксируемых объектов, задействованных в одном запросе. Если один запрос включает вызовы сотен или тысяч проксированных методов, то накладные расходы становятся значительными и их нельзя игнорировать.
 *
 * Для таких редких сценариев, когда требования не могут быть решены с помощью систем на основе прокси, предпочтительнее использовать byte code weaving. При byte code weaving берутся классы и аспекты, а на выходе получаются woven файлы .class. Поскольку аспекты вплетаются непосредственно в код, это обеспечивает лучшую производительность, но сложнее в реализации по сравнению с Spring AOP.
 *
 */

@SpringBootApplication
public class SpringMainRunner implements CommandLineRunner {

    private final Pojo pojo;

    public SpringMainRunner(Pojo pojo) {
        this.pojo = pojo;
    }

    public static void main(String[] args) {
        SpringApplication.run(SpringMainRunner.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        pojo.test();
        System.out.println("Out of Test");
        pojo.testUtil();
    }
}
