package main.tests;

import lombok.Data;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

/**
 * <img src="https://habrastorage.org/r/w1560/webt/sv/ru/1d/svru1d4lpapnwhjllxc2dfw5do4.png"/>
 * Java Development Kit — комплект разработчика приложений на языке Java. Он включает в себя Java Development Tools и среду выполнения Java — JRE (Java Runtime Environment).
 * <p>
 * Java development tools включают в себя около 40 различных тулов: javac (компилятор), java (лаунчер для приложений), javap (java class file disassembler), jdb (java debugger) и др.
 * <p>
 * Среда выполнения JRE — это пакет всего необходимого для запуска скомпилированной Java-программы. Включает в себя виртуальную машину JVM и библиотеку классов Java — Java Class Library.
 * <p>
 * JVM — это программа, предназначенная для выполнения байт-кода. Первое преимущество JVM — это принцип “Write once, run anywhere”. Он означает, что приложение, написанное на Java, будет работать одинаково на всех платформах. Это является большим преимуществом JVM и самой Java.
 * <ul>
 *     <li>
 *         Загрузка байт-кода и создание экземпляра класса Class. Грубо говоря, чтобы попасть на JVM, класс должен быть загружен. Для этого существуют отдельные класс-загрузчики, к ним мы вернемся чуть позже.
 *     </li>
 *     <li>
 * Согласно спецификации Java SE, для того, чтобы получить код, работающий в JVM, необходимо выполнить 3 этапа:
 * Связывание или линковка
 * После загрузки класса начинается процесс линковки, на котором байт-код разбирается и проверяется. Процесс линковки в свою очередь происходит в 3 шага:
 *
 * <ul>
 *     <li>verification или проверка байт-кода: проверяется корректность инструкций, возможность переполнения стека на данном участке кода, совместимость типов переменных; проверка происходит один раз для каждого класса;</li>
 *     <li>preparation или подготовка: на данном этапе в соответствии со спецификацией выделяется память под статические поля и происходит их инициализация;</li>
 *     <li>resolution или разрешение: разрешение символьных ссылок (когда в байт-коде мы открываем файлы с расширением .class, мы видим числовые значения вместо символьных ссылок).</li>
 * </ul>
 *     </li>
 *     <li>
 * Инициализация полученного объекта Class
 * На последнем этапе класс, который мы создали, инициализируется, и JVM может начинать его исполнение.
 *     </li>
 * </ul>
 *
 * <h2>
 * 5. Исполнение байт-кода на JVM
 * </h2>
 * <p>
 * В первую очередь, для исполнения байт-кода, JVM может его интерпретировать. Интерпретация — довольно медленный процесс. В процессе интерпретации, интерпретатор “бежит” построчно по класс-файлу и переводит его в команды, которые понятны JVM.
 * <p>
 * Также JVM может его транслировать, т.е. скомпилировать в машинный код, который будет исполняться непосредственно на CPU.
 * <p>
 * Команды, которые исполняются часто, не будут интерпретироваться, а сразу будут транслироваться.
 *
 * <h2>
 * 6. Компиляция
 * </h2>
 * <p>
 * Компилятор — это программа, которая преобразует исходные части программ, написанные на языке программирования высокого уровня, в программу на машинном языке, “понятную” компьютеру.
 * <p>
 * Компиляторы делятся на:
 * <p>
 * Не оптимизирующие
 * Простые оптимизирующие (Hotspot Client): работают быстро, но порождают неоптимальный код
 * Сложные оптимизирующие (Hotspot Server): производят сложные оптимизирующие преобразования прежде чем сформировать байт-код
 * <p>
 * <p>
 * Также компиляторы могут классифицироваться по моменту компиляции:
 * <p>
 * Динамические компиляторы
 * Работают одновременно с программой, что сказывается на производительности. Важно, чтобы эти компиляторы работали на коде, который часто исполняется. Во время исполнения программы JVM знает, какой код выполняется чаще всего, и, чтобы постоянно не интерпретировать его, виртуальная машина сразу переводит его в команды, которые уже будут исполняться непосредственно на процессорe.
 * Статические компиляторы
 * Дольше компилируют, но порождают оптимальный код для исполнения. Из плюсов: не требуют ресурсов во время исполнения программы, каждый метод компилируется с применением оптимизаций.
 */

public class Main {

    private String str = "hellO";
    private int a = 5;
    private final int b;

    public Main(int b) {
        this.b = b;
    }

    public static void main(String[] args) {
        outOfMemoryError();
    }



    private static void outOfMemoryError() {
        List<Person> personList = new ArrayList<>();
        while (true) {
            Person person = new Person();
            person.setName("Egor");
            personList.add(person);
            personList.addAll(personList);
            System.gc();
        }
    }

    private static void recursiveStackOverflow() {
        Person person = new Person();
        person.setName("Egor");
        recursiveStackOverflow();
    }

    @Data
    private static class Person {
        private String name;
    }

}