package patterns.strategy;

/**
 * Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих
 * алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять
 * прямо во время исполнения программы.
 * <br>
 * <b>Проблема</b>
 * Вы решили написать приложение-навигатор для путешественников. Оно должно показывать красивую и удобную карту,
 * позволяющую с лёгкостью ориентироваться в незнакомом городе.
 * <br>
 * Одной из самых востребованных функций являлся поиск и прокладывание маршрутов. Пребывая в неизвестном ему городе,
 * пользователь должен иметь возможность указать начальную точку и пункт назначения, а навигатор — проложит оптимальный путь.
 * <br>
 * Первая версия вашего навигатора могла прокладывать маршрут лишь по дорогам, поэтому отлично подходила
 * для путешествий на автомобиле. Но, очевидно, не все ездят в отпуск на машине. Поэтому следующим шагом вы
 * добавили в навигатор прокладывание пеших маршрутов.
 * <br>
 * Через некоторое время выяснилось, что некоторые люди предпочитают ездить по городу на общественном транспорте.
 * Поэтому вы добавили и такую опцию прокладывания пути.
 * <br>
 * Но и это ещё не всё. В ближайшей перспективе вы хотели бы добавить прокладывание маршрутов по велодорожкам.
 * А в отдалённом будущем — интересные маршруты посещения достопримечательностей.
 * <b>Решение</b>
 * Паттерн Стратегия предлагает определить семейство схожих алгоритмов, которые часто изменяются или расширяются, и вынести их в собственные классы, называемые стратегиями.
 * <br>
 * Вместо того, чтобы изначальный класс сам выполнял тот или иной алгоритм, он будет играть роль контекста, ссылаясь на одну из стратегий и делегируя ей выполнение работы. Чтобы сменить алгоритм, вам будет достаточно подставить в контекст другой объект-стратегию.
 * <br>
 * <p>
 * Важно, чтобы все стратегии имели общий интерфейс. Используя этот интерфейс, контекст будет независимым от конкретных классов стратегий. С другой стороны, вы сможете изменять и добавлять новые виды алгоритмов, не трогая код контекста.
 * <br>
 * <img src="https://refactoring.guru/images/patterns/diagrams/strategy/solution.png"/>
 * <br>
 * В нашем примере каждый алгоритм поиска пути переедет в свой собственный класс.
 * В этих классах будет определён лишь один метод, принимающий в параметрах координаты
 * начала и конца пути, а возвращающий массив точек маршрута.
 * <br>
 * Хотя каждый класс будет прокладывать маршрут по-своему, для навигатора это не будет иметь
 * никакого значения, так как его работа заключается только в отрисовке маршрута. Навигатору
 * достаточно подать в стратегию данные о начале и конце маршрута, чтобы получить массив точек
 * маршрута в оговорённом формате.
 * <br>
 * Класс навигатора будет иметь метод для установки стратегии, позволяя изменять стратегию поиска
 * пути на лету. Такой метод пригодится клиентскому коду навигатора, например, переключателям типов
 * маршрутов в пользовательском интерфейсе.
 * <br>
 * <b>Структура</b>
 * <img src="https://refactoring.guru/images/patterns/diagrams/strategy/structure.png"/>
 */

public class Strategy {
}
