package main;

/**
 * <h2>1. Класс String</h2>
 * <p>
 * Класс String отвечает за создание строк, состоящих из символов. А если быть точнее, заглянув в реализацию и посмотрев способ их хранения, то строки представляют собой массив символов (так было до Java 9):
 * private final char value[];
 * Начиная с Java 9 строки хранятся, как массив байт:
 * private final byte[] value;
 * Причину смены используемого типа вы можете узнать из статьи «Компактные строки в Java 9».
 * Строки в Java являются immutable, т. е. неизменяемыми.
 * Создать объект класса String можно двумя способами: при помощи строкового литерала и конструктора.
 * Первый способ, а он является рекомендуемым, удобен и прост. Под строковым литералом понимается последовательность символов, заключенных в двойные кавычки:
 * String stringLiteral = "TopJava";
 * Класс String имеет в своем распоряжении множество конструкторов, которые могут принимать на вход данные разного типа. Например, строковый литерал:
 * String stringViaConstructor = new String("TopJava");
 * или массив символов:
 * char[] chars = { 'T', 'o', 'p', 'J', 'a', 'v', 'a' };
 * String str = new String(chars);
 * Рассмотрим механизм создания и хранения строк более подробно.
 * <h2>2. Интернирование строк</h2>
 * Экземпляр класса String хранится в памяти, именуемой куча (heap), но есть некоторые нюансы. Если строка, созданная при помощи конструктора хранится непосредственно в куче, то строка, созданная как строковый литерал, уже хранится в специальном месте кучи — в так называемом пуле строк (string pool). В нем сохраняются исключительно уникальные значения строковых литералов, а не все строки подряд. Процесс помещения строк в пул называется интернирование (от англ. interning).
 * Когда мы объявляем переменную типа String и присваиваем ей строковый литерал, то JVM обращается в пул строк и ищет там такое же значение. Если пул содержит необходимое значение, то компилятор просто возвращает ссылку на соответствующий адрес строки без выделения дополнительной памяти. Если значение не найдено, то новая строка будет интернирована, а ссылка на нее возвращена и присвоена переменной.
 */
public class Main {

    public static void main(String[] args) {
        example1();

        printDelimiter();

        example2();

        printDelimiter();

        example3();

        printDelimiter();

        example4();

        printDelimiter();

        example5();

        printDelimiter();

        example6();

    }

    private static void example1() {
        String str1 = "TopJava";
        String str2 = "TopJava";
        System.out.println(str1 == str2);
    }

    /**
     * <img src="https://thumb.tildacdn.com/tild3731-3831-4761-a165-616437383964/-/resize/760x/-/format/webp/Frame_215.jpg"/>
     */
    private static void example2() {
        String str3 = "TopJava";
        String str4 = "Top" + "Java";
        System.out.println(str3 == str4);
    }

    /**
     * <img src="https://thumb.tildacdn.com/tild6531-3136-4866-b334-383731333836/-/resize/760x/-/format/webp/carbon_29.png"/>
     * Причиной получения false является то, что интернирование происходит не во время работы приложения (runtime), а во время компиляции.
     * А т.к. значение строки str3 вычисляется во время выполнения приложения, то на этапе компиляции оно не известно и потому, не добавляется в пул строк.
     */
    private static void example3() {
        String str1 = "TopJava";
        String str2 = "Java";
        String str3 = "Top" + str2;
        System.out.println(str1 == str3);
    }

    /**
     * Теперь давайте рассмотрим детальнее процесс создания объекта String при помощи конструктора.
     * Когда мы создаем экземпляр класса String с помощью оператора new, компилятор размещает строки в куче. При этом каждая строка, созданная таким способом, помещается в кучу (и имеет свою ссылку), даже если такое же значение уже есть в куче или в пуле строк.
     * Создадим строки через интернирование и с помощью конструктора, а затем сравним их ссылки:
     * <img src="https://thumb.tildacdn.com/tild3231-3735-4564-b235-333766393963/-/resize/760x/-/format/webp/Frame_214.png"/>
     */
    private static void example4() {
        String str1 = "TopJava";
        String str2 = "TopJava";

        String str3 = new String("TopJava");
        String str4 = new String("TopJava");

        System.out.println(str1 == str2);
        System.out.println(str2 == str3);
        System.out.println(str4 == str3);

    }

    /**
     * В Java существует возможность вручную выполнить интернирование строки в пул путем вызова метода intern() у объекта типа String.
     * Видоизменим приведенный ранее пример, добавив метод intern() к созданным при помощи конструктора строкам:
     * <img src="https://thumb.tildacdn.com/tild3532-6331-4566-b735-373630383863/-/resize/760x/-/format/webp/Frame_202.jpg"/>
     */
    private static void example5() {
        String str1 = "TopJava";
        String str2 = "TopJava";

        String str3 = new String("TopJava").intern();
        String str4 = new String("TopJava").intern();

        System.out.println(str1 == str2);
        System.out.println(str2 == str3);
        System.out.println(str4 == str3);

    }

    /**
     * <img src="https://thumb.tildacdn.com/tild3038-3035-4539-b132-303030616535/-/resize/760x/-/format/webp/Frame_203.jpg"/>
     * Поясним результат. Строки str1 и str2 добавлены в пул строк на этапе компиляции.
     * Во время выполнения программы происходит конкатенация строки «interned «со значением строки str2,
     * с последующим интернированием получившейся строки в пул строк (благодаря методу intern ()).
     * Но, так как пул строк уже содержит строку «interned TopJava», объекту String str3 будет присвоена ссылка на строку в пуле строк и соответственно,
     * выражение равенства ссылок «==» будет истинным.
     * Принимая во внимание всё вышесказанное, вы можете спросить: «Почему бы все строки сразу после их создания не добавлять в пул строк?
     * Ведь это приведет к экономии памяти…». Да, среди достаточно большого количества программистов такое заблуждение присутствует.
     * Именно заблуждение, поскольку не все учитывают дополнительные затраты виртуальной машины на процесс интернирования,
     * а также падение производительности в целом. Тесты и наглядное подтверждение этого приводятся в видео докладе
     * Алексея Шипилёва — «Катехизис java.lang.String». Финализируя доклад Алексея можно сказать, что интернирование
     * (в виде применения метода intern ()) рекомендуется вообще не использовать. Вместо интернирования необходимо использовать дедупликацию (рассматривается далее).
     */
    private static void example6() {
        String str1 = "TopJava";
        String str2 = "Java";
        String str3 = ("Top" + str2).intern();
        System.out.println(str1 == str3);
    }

    private static void printDelimiter() {
        System.out.println("---------------------------");
    }

}
